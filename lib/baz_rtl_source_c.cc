/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * gr-baz by Balint Seeber (http://spench.net/contact)
 * Information, documentation & samples: http://wiki.spench.net/wiki/gr-baz
 * This block uses source from rtl-sdr: http://sdr.osmocom.org/trac/wiki/rtl-sdr
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <baz_rtl_source_c.h>
#include <gr_io_signature.h>
#include <stdio.h>

#include "rtl2832-tuner_e4000.h"
#include "rtl2832-tuner_fc0013.h"

/*
 * Create a new instance of howto_square_ff and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
baz_rtl_source_c_sptr 
baz_make_rtl_source_c (bool auto_tuner_mode /*= false*/)
{
  return baz_rtl_source_c_sptr (new baz_rtl_source_c (auto_tuner_mode));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 0;	// mininum number of input streams
static const int MAX_IN = 0;	// maximum number of input streams
static const int MIN_OUT = 1;	// minimum number of output streams
static const int MAX_OUT = 1;	// maximum number of output streams

// COMPAT /////////////////////////////////////////////////////////////////////
#define _T(x)		x
#define ZeroMemory(p,l)			memset(p, 0x00, l)
#define SAFE_DELETE_ARRAY(p)	{ if (p) { delete [] p; p = NULL; } }
#define SAFE_DELETE(p)			{ if (p) { delete p; p = NULL; } }
#define min(a,b)				(a < b ? a : b)
#define FALSE					0

typedef uint8_t		BYTE, *LPBYTE;
typedef uint32_t	UINT;
///////////////////////////////////////////////////////////////////////////////

#define READLEN		(/*16 * */16384)	// Smaller read lengths result in minor break-up on constant tone AM, too large and spectrum display jumps on screen
#define BUFFER_MUL	4					// Buffer size = BUFFER_MUL * READLEN (buffering stops when half-full)

/*
 * The private constructor
 */
baz_rtl_source_c::baz_rtl_source_c (bool auto_tuner_mode /*= false*/)
  : gr_block ("baz_rtl_source_c",
	      gr_make_io_signature (MIN_IN, MAX_IN, sizeof (float)),
	      gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (gr_complex)))
	/////////////////////////// COMPAT
	, m_dFreq(0)
	, m_dGain(0)
	, m_dSampleRate(0)
	/////////////////////////// COMPAT
	, m_nSamplesReceived(0)
	, m_nOverflows(0)
	, m_bRunning(false)
	///////////////////////////
	, devh(NULL)
	, m_auto_tuner_mode(auto_tuner_mode)
	, m_nBufferItems(0)
	, m_pUSBBuffer(NULL)
	, m_nBufferStart(0)
	, m_nBufferSize(0)
	, tuner_type(TUNER_UNKNOWN)
	, m_bBuffering(false)
	, m_iTunerGainMode(RTL2832_E4000_TUNER_GAIN_NORMAL)
	, m_libusb_init_done(false)
{
  m_recv_samples_per_packet = /*READLEN / (1+1)*/4096;
  set_output_multiple(m_recv_samples_per_packet);
  
  if (Create() == false)
	throw std::runtime_error("Failed to create rtl2832 source");
}

/*
 * Our virtual destructor.
 */
baz_rtl_source_c::~baz_rtl_source_c ()
{
  Destroy();
}

int 
baz_rtl_source_c::general_work (int noutput_items,
			       gr_vector_int &ninput_items,
			       gr_vector_const_void_star &input_items,
			       gr_vector_void_star &output_items)
{
  //const float *in = (const float *) input_items[0];
  gr_complex *out = (gr_complex *)output_items[0];
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
  gruel::scoped_lock lock(d_mutex);

	if ((m_bRunning == false) || (devh == NULL))
	{
	  fprintf(stderr, _T("work called while not running!\n"));
		return -1;
	}
	  
	if (noutput_items > m_nBufferSize)
	{
	  fprintf(stderr, _T("work wants more than the buffer size!\n"));
	  noutput_items = m_nBufferSize;
	}

	while ((m_bBuffering) || (m_nBufferItems < /*m_recv_samples_per_packet*/noutput_items))
	{
	  m_hPacketEvent.wait(lock);
	  
	  if ((m_bRunning == false) || (devh == NULL))	// m_hStopEvent
	  {
		fprintf(stderr, _T("No longer running after packet notification - signalling EOF...\n"));
		return -1;
	  }
	  
	  if (m_bBuffering == false)	// m_hAbortEvent
		break;

	  fprintf(stderr, _T("Caught packet signal while buffering!\n"));
	}

	if (m_nBufferItems < m_recv_samples_per_packet)
	{
		fprintf(stderr, _T("Reading packet after signal, but not enough items in buffer (only %lu, need at least: %lu, start now %lu)\n"), m_nBufferItems, m_recv_samples_per_packet, m_nBufferStart);	// FIXME: Why does this happen?
		m_bBuffering = true;
		return 0;
	}
	else if (m_nBufferItems < noutput_items)
	{
	  fprintf(stderr, _T("Not enough items for work (only %lu, need at least: %lu, start now %lu)\n"), m_nBufferItems, noutput_items, m_nBufferStart);
	  noutput_items = m_nBufferItems;
	}

	UINT nPart1 = min(/*m_recv_samples_per_packet*/noutput_items, m_nBufferSize - m_nBufferStart);
	LPBYTE p = m_pUSBBuffer + (m_nBufferStart * (1+1));
	for (UINT n = 0; n < nPart1; n++)
	{
		short i = p[n*2+0];
		short q = p[n*2+1];
		out[n] = gr_complex(i - 127, q - 127);
	}

	UINT nResidual = /*m_recv_samples_per_packet*/noutput_items - nPart1;
	if (nResidual > 0)
	{
		for (UINT n = 0; n < nResidual; n++)
		{
			short i = m_pUSBBuffer[n*2+0];
			short q = m_pUSBBuffer[n*2+1];
			out[nPart1 + n] = gr_complex(i - 127, q - 127);
		}
	}

	m_nSamplesReceived += m_recv_samples_per_packet;

/*	if (false)	// FIXME: Flag
	{
		++m_nOverflows;

		m_metadata.error_code = uhd::rx_metadata_t::ERROR_CODE_OVERFLOW;
	}
	else
		m_metadata.error_code = uhd::rx_metadata_t::ERROR_CODE_NONE;
*/
	m_nBufferItems -= m_recv_samples_per_packet;

	//ASSERT(m_nBufferItems != -1);

	if (m_nBufferItems > 0)
		m_nBufferStart = (m_nBufferStart + m_recv_samples_per_packet) % m_nBufferSize;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

  //for (int i = 0; i < noutput_items; i++){
  //  out[i] = in[i] * in[i];
  //}

  // Tell runtime system how many input items we consumed on
  // each input stream.
  //consume_each (/*noutput_items*/0);

  // Tell runtime system how many output items we produced.
  return noutput_items;
}

///////////////////////////////////////////////////////////////////////////////
/* ezcap USB 2.0 DVB-T/DAB/FM stick */
#define EZCAP_VID	0x0bda
#define EZCAP_PID	0x2838

#define BANDWIDTH	8000000

/* Terratec NOXON DAB/DAB+ USB-Stick */
#define NOXON_VID	0x0ccd
#define NOXON_PID	0x00b3

#define CTRL_IN		(LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_ENDPOINT_IN)
#define CTRL_OUT	(LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_ENDPOINT_OUT)

#define CRYSTAL_FREQ	28800000

enum usb_reg {
	USB_SYSCTL		= 0x2000,
	USB_CTRL		= 0x2010,
	USB_STAT		= 0x2014,
	USB_EPA_CFG		= 0x2144,
	USB_EPA_CTL		= 0x2148,
	USB_EPA_MAXPKT		= 0x2158,
	USB_EPA_MAXPKT_2	= 0x215a,
	USB_EPA_FIFO_CFG	= 0x2160,
};

enum sys_reg {
	DEMOD_CTL		= 0x3000,
	GPO			= 0x3001,
	GPI			= 0x3002,
	GPOE			= 0x3003,
	GPD			= 0x3004,
	SYSINTE			= 0x3005,
	SYSINTS			= 0x3006,
	GP_CFG0			= 0x3007,
	GP_CFG1			= 0x3008,
	SYSINTE_1		= 0x3009,
	SYSINTS_1		= 0x300a,
	DEMOD_CTL_1		= 0x300b,
	IR_SUSPEND		= 0x300c,
};

enum blocks {
	DEMODB			= 0,
	USBB			= 1,
	SYSB			= 2,
	TUNB			= 3,
	ROMB			= 4,
	IRB				= 5,
	IICB			= 6,
};
/////////////////////////////////////////////////////////////////////////////

int baz_rtl_source_c::find_device()
{
  if (devh != NULL)
	return 0;
  
	devh = libusb_open_device_with_vid_pid(NULL, EZCAP_VID, EZCAP_PID);
	if (devh > 0) {
		tuner_type = TUNER_E4000;
		fprintf(stderr, "Found ezcap stick with E4000 tuner\n");
		fprintf(stderr, "E4000 auto tuner mode: %s\n", (m_auto_tuner_mode ? "on" : "off"));
		return 0;
	}

	devh = libusb_open_device_with_vid_pid(NULL, NOXON_VID, NOXON_PID);
	if (devh > 0) {
		tuner_type = TUNER_FC0013;
		fprintf(stderr, "Found Terratec NOXON stick with FC0013 tuner\n");
		return 0;
	}

	return -EIO;
}

int baz_rtl_source_c::rtl_read_array(uint8_t block, uint16_t addr, uint8_t *array, uint8_t len)
{
  if (devh == NULL)
	return LIBUSB_ERROR_NO_DEVICE;
  
	int r;
	uint16_t index = (block << 8);

	r = libusb_control_transfer(devh, CTRL_IN, 0, addr, index, array, len, 0);

	return r;
}

int baz_rtl_source_c::rtl_write_array(uint8_t block, uint16_t addr, uint8_t *array, uint8_t len)
{
  if (devh == NULL)
	return LIBUSB_ERROR_NO_DEVICE;
  
	int r;
	uint16_t index = (block << 8) | 0x10;

	r = libusb_control_transfer(devh, CTRL_OUT, 0, addr, index, array, len, 0);
	if (r == 0)
	{
		fprintf(stderr, _T("No bytes xfered\n"));
	}
	else if (r < 0)
	{
/* \returns on success, the number of bytes actually transferred
 * \returns LIBUSB_ERROR_TIMEOUT if the transfer timed out
 * \returns LIBUSB_ERROR_PIPE if the control request was not supported by the
 * device
 * \returns LIBUSB_ERROR_NO_DEVICE if the device has been disconnected
 * \returns another LIBUSB_ERROR code on other failures
*/
		if (r == LIBUSB_ERROR_PIPE)
			fprintf(stderr, _T("USB control request no supported\n"));
		else
			fprintf(stderr, _T("Error writing control: %i\n"), r);
	}

	return r;
}

int baz_rtl_source_c::rtl_i2c_write(uint8_t i2c_addr, uint8_t *buffer, int len)
{
	uint16_t addr = i2c_addr;
	return rtl_write_array(IICB, addr, buffer, len);
}

int baz_rtl_source_c::rtl_i2c_read(uint8_t i2c_addr, uint8_t *buffer, int len)
{
	uint16_t addr = i2c_addr;
	return rtl_read_array(IICB, addr, buffer, len);
}

uint16_t baz_rtl_source_c::rtl_read_reg(uint8_t block, uint16_t addr, uint8_t len)
{
  if (devh == NULL)
	return 0;
  
	int r;
	unsigned char data[2];
	uint16_t index = (block << 8);
	uint16_t reg;

	r = libusb_control_transfer(devh, CTRL_IN, 0, addr, index, data, len, 0);

	if (r < 0)
		fprintf(stderr, "%s failed\n", __FUNCTION__);

	reg = (data[1] << 8) | data[0];

	return reg;
}

void baz_rtl_source_c::rtl_write_reg(uint8_t block, uint16_t addr, uint16_t val, uint8_t len)
{
  if (devh == NULL)
	return;
  
	int r;
	unsigned char data[2];

	uint16_t index = (block << 8) | 0x10;

	if (len == 1)
		data[0] = val & 0xff;
	else
		data[0] = val >> 8;

	data[1] = val & 0xff;

	r = libusb_control_transfer(devh, CTRL_OUT, 0, addr, index, data, len, 0);

	if (r < 0)
		fprintf(stderr, "%s failed\n", __FUNCTION__);
}

uint16_t baz_rtl_source_c::demod_read_reg(uint8_t page, uint8_t addr, uint8_t len)
{
  if (devh == NULL)
	return 0;
  
	int r;
	unsigned char data[2];

	uint16_t index = page;
	uint16_t reg;
	addr = (addr << 8) | 0x20;

	r = libusb_control_transfer(devh, CTRL_IN, 0, addr, index, data, len, 0);

	if (r < 0)
		fprintf(stderr, "%s failed\n", __FUNCTION__);

	reg = (data[1] << 8) | data[0];

	return reg;
}

void baz_rtl_source_c::demod_write_reg(uint8_t page, uint16_t addr, uint16_t val, uint8_t len)
{
  if (devh == NULL)
	return;
  
	int r;
	unsigned char data[2];
	uint16_t index = 0x10 | page;
	addr = (addr << 8) | 0x20;

	if (len == 1)
		data[0] = val & 0xff;
	else
		data[0] = val >> 8;

	data[1] = val & 0xff;

	r = libusb_control_transfer(devh, CTRL_OUT, 0, addr, index, data, len, 0);

	if (r < 0)
		fprintf(stderr, "%s failed\n", __FUNCTION__);

	demod_read_reg(0x0a, 0x01, 1);
}

bool baz_rtl_source_c::set_samp_rate(uint32_t samp_rate)
{
	uint16_t tmp;
	uint32_t rsamp_ratio;
	double real_rate;

	/* check for the maximum rate the resampler supports */
	if (samp_rate > 3200000)
		samp_rate = 3200000;

	rsamp_ratio = ((uint64_t)CRYSTAL_FREQ * (uint64_t)pow(2, 22)) / (uint64_t)samp_rate;
	rsamp_ratio &= ~3;

	if (rsamp_ratio == 0)
		return false;

	real_rate = (CRYSTAL_FREQ * pow(2, 22)) / rsamp_ratio;

	fprintf(stderr, "Setting sample rate: %.3f Hz\n", real_rate);

	m_dSampleRate = real_rate;

	tmp = (rsamp_ratio >> 16);
	demod_write_reg(1, 0x9f, tmp, 2);
	tmp = rsamp_ratio & 0xffff;
	demod_write_reg(1, 0xa1, tmp, 2);

	return true;
}

void baz_rtl_source_c::set_i2c_repeater(int on)
{
	demod_write_reg(1, 0x01, on ? 0x18 : 0x10, 1);
}

void baz_rtl_source_c::rtl_init(void)
{
	unsigned int i;

	/* default FIR coefficients used for DAB/FM by the Windows driver,
	 * the DVB driver uses different ones */
	uint8_t fir_coeff[] = {
		0xca, 0xdc, 0xd7, 0xd8, 0xe0, 0xf2, 0x0e, 0x35, 0x06, 0x50,
		0x9c, 0x0d, 0x71, 0x11, 0x14, 0x71, 0x74, 0x19, 0x41, 0x00,
	};

	/* initialize USB */
	rtl_write_reg(USBB, USB_SYSCTL, 0x09, 1);
	rtl_write_reg(USBB, USB_EPA_MAXPKT, 0x0002, 2);
	rtl_write_reg(USBB, USB_EPA_CTL, 0x1002, 2);

	/* poweron demod */
	rtl_write_reg(SYSB, DEMOD_CTL_1, 0x22, 1);
	rtl_write_reg(SYSB, DEMOD_CTL, 0xe8, 1);

	/* reset demod (bit 3, soft_rst) */
	demod_write_reg(1, 0x01, 0x14, 1);
	demod_write_reg(1, 0x01, 0x10, 1);

	/* disable spectrum inversion and adjacent channel rejection */
	demod_write_reg(1, 0x15, 0x00, 1);
	demod_write_reg(1, 0x16, 0x0000, 2);

	/* set IF-frequency to 0 Hz */
	demod_write_reg(1, 0x19, 0x0000, 2);

	/* set FIR coefficients */
	for (i = 0; i < sizeof (fir_coeff); i++)
		demod_write_reg(1, 0x1c + i, fir_coeff[i], 1);

	demod_write_reg(0, 0x19, 0x25, 1);

	/* init FSM state-holding register */
	demod_write_reg(1, 0x93, 0xf0, 1);

	/* disable AGC (en_dagc, bit 0) */
	demod_write_reg(1, 0x11, 0x00, 1);

	/* disable PID filter (enable_PID = 0) */
	demod_write_reg(0, 0x61, 0x60, 1);

	/* opt_adc_iq = 0, default ADC_I/ADC_Q datapath */
	demod_write_reg(0, 0x06, 0x80, 1);

	/* Enable Zero-IF mode (en_bbin bit), DC cancellation (en_dc_est),
	 * IQ estimation/compensation (en_iq_comp, en_iq_est) */
	demod_write_reg(1, 0xb1, 0x1b, 1);
}

bool baz_rtl_source_c::tuner_init(int frequency)
{
  bool bReturn = false;
  
	set_i2c_repeater(1);

	switch (tuner_type) {
	case TUNER_E4000:
		if (e4000_Initialize(this) != 0)
		{
			fprintf(stderr, _T("e4000_Initialize failed"));
			goto tuner_init_error;
		}
		if (e4000_SetBandwidthHz(this, BANDWIDTH) != 0)
		{
			fprintf(stderr, _T("e4000_SetBandwidthHz failed"));
			goto tuner_init_error;
		}
		//e4000_SetRfFreqHz(this, frequency);
		break;
	case TUNER_FC0013:
		if (FC0013_Open(this) != 0)
		{
			fprintf(stderr, _T("FC0013_Open failed"));
			goto tuner_init_error;
		}
		//FC0013_SetFrequency(frequency/1000, 8);
		break;
	default:
		fprintf(stderr, "No valid tuner available!");
		break;
	}

	bReturn = true;
tuner_init_error:
	set_i2c_repeater(0);
	//fprintf(stderr, "Tuned to %i Hz\n", frequency);
	return bReturn;
}

///////////////////////////////////////////////////////////////////////////////
bool baz_rtl_source_c::Create(/*const char* strHint = NULL*/)
{
	Destroy();
	
	m_nBufferSize = (READLEN / (1+1)) * BUFFER_MUL;
	m_pUSBBuffer = new BYTE[m_nBufferSize * (1+1)];
	ZeroMemory(m_pUSBBuffer, m_nBufferSize * (1+1));

	/////////////////////////

	int r;

	if (m_libusb_init_done == false)
	{
	  r = libusb_init(NULL);
	  if (r < 0) {
		  fprintf(stderr, "Failed to initialise libusb\n");
		  return false;
	  }
	  
	  m_libusb_init_done = true;
	}

	r = find_device();
	if (r < 0) {
		fprintf(stderr, "Could not find/open device\n");
		Destroy();
		return false;
	}

	r = libusb_claim_interface(devh, 0);
	if (r < 0) {
		fprintf(stderr, "usb_claim_interface error: %d\n", r);
		Destroy();
		return false;
	}

	rtl_init();
	if (tuner_init(0) == false)
	  return false;

	return true;
}

void baz_rtl_source_c::Destroy()
{
	Stop();

	if (devh != NULL)
	{
		libusb_release_interface(devh, 0);
		libusb_close(devh);
		devh = NULL;
	}

	if (m_libusb_init_done)
	{
	  libusb_exit(NULL);
	  m_libusb_init_done = false;
	}

	SAFE_DELETE_ARRAY(m_pUSBBuffer);
}

static void _CaptureThreadProc(baz_rtl_source_c* p)
{
	return p->CaptureThreadProc();
}

void baz_rtl_source_c::Reset()
{
	m_nBufferStart = 0;
	m_nBufferItems = 0;
	m_nSamplesReceived = 0;
}

bool baz_rtl_source_c::Start()
{
  gruel::scoped_lock lock(d_mutex);
  
	if (m_bRunning)
		return true;

	Reset();

	/* reset endpoint before we start reading */
	rtl_write_reg(USBB, USB_EPA_CTL, 0x1002, 2);
	rtl_write_reg(USBB, USB_EPA_CTL, 0x0000, 2);

	m_bBuffering = true;

	m_bRunning = true;
	
	m_pCaptureThread = gruel::thread(_CaptureThreadProc, this);

	return true;
}

void baz_rtl_source_c::Stop()
{
	gruel::scoped_lock lock(d_mutex);

	if (m_bRunning == false)
		return;
	  
	m_bRunning = false;
	
	m_hPacketEvent.notify_one();	// In case general_work is waiting

	lock.unlock();
	
	m_pCaptureThread.join();
}

static int GetMapIndex(int iValue, const int* map, int iCount)
{
	int i = 0;
	for (; i < iCount; i++)
	{
		if (map[i*2 + 0] >= iValue)
		{
			if (map[i*2 + 0] > iValue)
				--i;

			break;
		}
	}

	if ((i == -1) || (i == iCount))
		return i;

	return (i*2/* + 1*/);
}

bool baz_rtl_source_c::set_gain(/*double*/float dGain)
{
	static int mapGainsE4000[] = {	// rtl2832: num_rtl2832_e4000.c
		-50,	2,
		-25,	3,
		0,		4,
		25,		5,
		50,		6,
		75,		7,
		100,	8,
		125,	9,
		150,	10,
		175,	11,
		200,	12,
		225,	13,
		250,	14,
		300,	15,	// Apparently still 250
	};
	
  /*enum FC0013_LNA_GAIN_VALUE
  {
	  FC0013_LNA_GAIN_LOW     = 0x00,	// -6.3dB
	  FC0013_LNA_GAIN_MIDDLE  = 0x08,	//  7.1dB
	  FC0013_LNA_GAIN_HIGH_17 = 0x11,	// 19.1dB
	  FC0013_LNA_GAIN_HIGH_19 = 0x10,	// 19.7dB
  };*/
	
	static int mapGainsFC0013[] = {	// rtl2832: num_rtl2832_fc0013.c
	  -63, 0x00,
	  +71, 0x08,
	  191, 0x11,
	  197, 0x10
	};
	
	int* mapGains = NULL;
	int iCount = 0;
	
	switch (tuner_type) {
	  case TUNER_E4000:
		mapGains = mapGainsE4000;
		iCount = (sizeof(mapGainsE4000)/sizeof(mapGainsE4000[0])) / 2;
		break;
	  case TUNER_FC0013:
		mapGains = mapGainsFC0013;
		iCount = (sizeof(mapGainsFC0013)/sizeof(mapGainsFC0013[0])) / 2;
		break;
	  default:
		return false;
	}

	int iGain = (int)(dGain * 10.0);
	int i = GetMapIndex(iGain, mapGains, iCount);

	if ((i == -1) || (i == iCount))
		return false;

	unsigned char u8Write = mapGains[i + 1];

	gruel::scoped_lock lock(d_mutex);

	set_i2c_repeater(1);

	if (tuner_type == TUNER_E4000)
	{
	  unsigned char u8Read = 0;
	  if (I2CReadByte(this, 0, RTL2832_E4000_LNA_GAIN_ADDR, &u8Read) != E4000_I2C_SUCCESS)
	  {
		  set_i2c_repeater(0);
		  fprintf(stderr, _T("I2C read failed"));
		  return false;
	  }
  
	  u8Write |= (u8Read & ~RTL2832_E4000_LNA_GAIN_MASK);
  
	  if (I2CWriteByte(this, 0, RTL2832_E4000_LNA_GAIN_ADDR, u8Write) != E4000_I2C_SUCCESS)
	  {
		  set_i2c_repeater(0);
		  fprintf(stderr, _T("I2C write failed"));
		  return false;
	  }
	}
	else if (tuner_type == TUNER_FC0013)
	{
/* FIXME: Also really should be handling:
	int boolVhfFlag;      // 0:false,  1:true
	int boolEnInChgFlag;  // 0:false,  1:true
	int intGainShift;
*/
	  if (fc0013_SetRegMaskBits(this, 0x14, 4, 0, u8Write) != FC0013_I2C_SUCCESS)
	  {
		set_i2c_repeater(0);
		fprintf(stderr, _T("I2C write failed"));
		return false;
	  }
	}

	m_dGain = (double)mapGains[i] / 10.0;

	set_i2c_repeater(0);

	/////////////////////////
	if (m_auto_tuner_mode)
	  SetTunerMode();
	/////////////////////////

	return true;
}

bool baz_rtl_source_c::set_frequency(/*double*/float dFreq)
{
	gruel::scoped_lock lock(d_mutex);

	set_i2c_repeater(1);
	
	switch (tuner_type) {
	case TUNER_E4000:
		if (e4000_SetRfFreqHz(this, (unsigned long)dFreq) != 0)
		{
			set_i2c_repeater(0);
			fprintf(stderr, _T("I2C write failed"));
			return false;
		}
		break;
	case TUNER_FC0013:
		if (FC0013_SetFrequency(this, (unsigned long)(dFreq/1000.0), 8) != 0)
		{
			set_i2c_repeater(0);
			fprintf(stderr, _T("I2C write failed"));
			return false;
		}
		break;
	default:
	  //break;
	  set_i2c_repeater(0);
	  return true;
	}

	set_i2c_repeater(0);

/*	m_tuneResult.target_rf_freq = dFreq;
	m_tuneResult.actual_rf_freq = ((dFreq + 500.0) / 1000.0);
*/
	m_dFreq = dFreq;

	return true;
}

bool baz_rtl_source_c::set_sample_rate(/*double*/int dSampleRate)
{
	gruel::scoped_lock lock(d_mutex);

	if (set_samp_rate((uint32_t)dSampleRate) == false)
		return false;

	return true;
}

///////////////////////////////////////////////////////////////////////////////

void baz_rtl_source_c::CaptureThreadProc()
{
	//fprintf(stderr, _T("Capture threading %04x starting...\n"), GetCurrentThreadId());

	gruel::scoped_lock lock(d_mutex, boost::defer_lock);

	LPBYTE pBuffer = new BYTE[READLEN];

	while (true)
	{
	  lock.lock();
	  if (m_bRunning == false)
		break;
	  lock.unlock();

		int lLockSize = 0;
		int res = libusb_bulk_transfer(devh, 0x81, pBuffer, READLEN, &lLockSize, 3000);
		if (res == LIBUSB_ERROR_OVERFLOW)
		{
			fprintf(stderr, _T("USB overrun\n"));

			lock.lock();
			++m_nOverflows;
			lock.unlock();
		}
		else if (res != 0)
		{
			fprintf(stderr, _T("USB error: %i\n"), res);
			lock.lock();
			m_bRunning = false;	// This will signal EOF
			m_hPacketEvent.notify_one();
			lock.unlock();
			//continue;
			//fprintf(stderr, _T("Capture thread aborting\n"));
			return;
		}

		if (lLockSize < READLEN)
		{
			fprintf(stderr, "Short bulk read, samples lost, exiting!\n");
		}

		lock.lock();

		UINT nRemaining = min(m_nBufferSize - m_nBufferItems, (UINT)lLockSize / (1+1));

		bool bSignal = true;

		if (nRemaining > 0)
		{
			//fprintf(stderr, _T("Notification: count=%lu, start=%lu, items=%lu\n"), nCount, m_nBufferStart, m_nBufferItems);

			LPBYTE p = m_pUSBBuffer + (((m_nBufferStart + m_nBufferItems) % m_nBufferSize) * (1+1));

			UINT nPart1 = (m_nBufferStart + m_nBufferItems) % m_nBufferSize;
			UINT nSize1 = min(nRemaining, m_nBufferSize - nPart1);

			memcpy(p, pBuffer, nSize1 * (1+1));

			UINT nResidual = nRemaining - nSize1;
			if (nResidual > 0)
				memcpy(m_pUSBBuffer, pBuffer + (nSize1 * 2), nResidual * (1+1));

			m_nBufferItems += nRemaining;

			if ((m_bBuffering) && (m_nBufferItems >= (m_nBufferSize / 2)))
			{
				fprintf(stderr, _T("Finished buffering (%lu/%lu)\n"), m_nBufferItems, m_nBufferSize);
				m_bBuffering = false;
			}

			bSignal = !m_bBuffering;
		}
		else// if (nRemaining == 0)
		{
fprintf(stderr, _T("OVERRUN: Remaining: %lu\n"), nRemaining);	// FIXME: Overrun
		}

		lock.unlock();

		if (bSignal)
			m_hPacketEvent.notify_one();
	}

	SAFE_DELETE_ARRAY(pBuffer);

	//fprintf(stderr, _T("Capture threading %04x exiting\n"), GetCurrentThreadId());
}

#define NO_USE 0

int baz_rtl_source_c::SetTunerMode()
{
  if (tuner_type != TUNER_E4000)
	return m_iTunerGainMode;

	static const long LnaGainTable[RTL2832_E4000_LNA_GAIN_TABLE_LEN][RTL2832_E4000_LNA_GAIN_BAND_NUM] =
	{
		// VHF Gain,	UHF Gain,		ReadingByte
		{-50,			-50	},		//	0x0
		{-25,			-25	},		//	0x1
		{-50,			-50	},		//	0x2
		{-25,			-25	},		//	0x3
		{0,				0	},		//	0x4
		{25,			25	},		//	0x5
		{50,			50	},		//	0x6
		{75,			75	},		//	0x7
		{100,			100	},		//	0x8
		{125,			125	},		//	0x9
		{150,			150	},		//	0xa
		{175,			175	},		//	0xb
		{200,			200	},		//	0xc
		{225,			250	},		//	0xd
		{250,			280	},		//	0xe
		{250,			280	},		//	0xf

		// Note: The gain unit is 0.1 dB.
	};

	static const long LnaGainAddTable[RTL2832_E4000_LNA_GAIN_ADD_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		NO_USE,		//	0x0
		NO_USE,		//	0x1
		NO_USE,		//	0x2
		0,			//	0x3
		NO_USE,		//	0x4
		20,			//	0x5
		NO_USE,		//	0x6
		70,			//	0x7

		// Note: The gain unit is 0.1 dB.
	};

	static const long MixerGainTable[RTL2832_E4000_MIXER_GAIN_TABLE_LEN][RTL2832_E4000_MIXER_GAIN_BAND_NUM] =
	{
		// VHF Gain,	UHF Gain,		ReadingByte
		{90,			40	},		//	0x0
		{170,			120	},		//	0x1

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage1GainTable[RTL2832_E4000_IF_STAGE_1_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		-30,		//	0x0
		60,			//	0x1

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage2GainTable[RTL2832_E4000_IF_STAGE_2_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		0,			//	0x0
		30,			//	0x1
		60,			//	0x2
		90,			//	0x3

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage3GainTable[RTL2832_E4000_IF_STAGE_3_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		0,			//	0x0
		30,			//	0x1
		60,			//	0x2
		90,			//	0x3

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage4GainTable[RTL2832_E4000_IF_STAGE_4_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		0,			//	0x0
		10,			//	0x1
		20,			//	0x2
		20,			//	0x3

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage5GainTable[RTL2832_E4000_IF_STAGE_5_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		0,			//	0x0
		30,			//	0x1
		60,			//	0x2
		90,			//	0x3
		120,		//	0x4
		120,		//	0x5
		120,		//	0x6
		120,		//	0x7

		// Note: The gain unit is 0.1 dB.
	};

	static const long IfStage6GainTable[RTL2832_E4000_IF_STAGE_6_GAIN_TABLE_LEN] =
	{
		// Gain,		ReadingByte
		0,			//	0x0
		30,			//	0x1
		60,			//	0x2
		90,			//	0x3
		120,		//	0x4
		120,		//	0x5
		120,		//	0x6
		120,		//	0x7

		// Note: The gain unit is 0.1 dB.
	};

	unsigned long RfFreqHz;
	int RfFreqKhz;
	unsigned long BandwidthHz;
	int BandwidthKhz;

	unsigned char ReadingByte;
	int BandIndex;

	unsigned char TunerBitsLna, TunerBitsLnaAdd, TunerBitsMixer;
	unsigned char TunerBitsIfStage1, TunerBitsIfStage2, TunerBitsIfStage3, TunerBitsIfStage4;
	unsigned char TunerBitsIfStage5, TunerBitsIfStage6;

	long TunerGainLna, TunerGainLnaAdd, TunerGainMixer;
	long TunerGainIfStage1, TunerGainIfStage2, TunerGainIfStage3, TunerGainIfStage4;
	long TunerGainIfStage5, TunerGainIfStage6;

	long TunerGainTotal;
	long TunerInputPower;

	/////////////////////////
	int TunerGainMode = -1;
	set_i2c_repeater(1);
	/////////////////////////

	// Get tuner RF frequency in KHz.
	// Note: RfFreqKhz = round(RfFreqHz / 1000)
	//if(this->GetRfFreqHz(this, &RfFreqHz) != E4000_I2C_SUCCESS)
	//	goto error_status_get_tuner_registers;
	RfFreqHz = (unsigned long)GetFreq();

	RfFreqKhz = (int)((RfFreqHz + 500) / 1000);

	// Get tuner bandwidth in KHz.
	// Note: BandwidthKhz = round(BandwidthHz / 1000)
	//if(pTunerExtra->GetBandwidthHz(this, &BandwidthHz) != E4000_I2C_SUCCESS)
	//	goto error_status_get_tuner_registers;
	BandwidthHz = BANDWIDTH;

	BandwidthKhz = (int)((BandwidthHz + 500) / 1000);

	// Determine band index.
	BandIndex = (RfFreqHz < RTL2832_E4000_RF_BAND_BOUNDARY_HZ) ? 0 : 1;

	// Get tuner LNA gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_LNA_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsLna = (ReadingByte & RTL2832_E4000_LNA_GAIN_MASK) >> RTL2832_E4000_LNA_GAIN_SHIFT;
	TunerGainLna = LnaGainTable[TunerBitsLna][BandIndex];

	// Get tuner LNA additional gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_LNA_GAIN_ADD_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsLnaAdd = (ReadingByte & RTL2832_E4000_LNA_GAIN_ADD_MASK) >> RTL2832_E4000_LNA_GAIN_ADD_SHIFT;
	TunerGainLnaAdd = LnaGainAddTable[TunerBitsLnaAdd];

	// Get tuner mixer gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_MIXER_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsMixer = (ReadingByte & RTL2832_E4000_MIXER_GAIN_MASK) >> RTL2832_E4000_LNA_GAIN_ADD_SHIFT;
	TunerGainMixer = MixerGainTable[TunerBitsMixer][BandIndex];

	// Get tuner IF stage 1 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_1_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage1 = (ReadingByte & RTL2832_E4000_IF_STAGE_1_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_1_GAIN_SHIFT;
	TunerGainIfStage1 = IfStage1GainTable[TunerBitsIfStage1];

	// Get tuner IF stage 2 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_2_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage2 = (ReadingByte & RTL2832_E4000_IF_STAGE_2_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_2_GAIN_SHIFT;
	TunerGainIfStage2 = IfStage2GainTable[TunerBitsIfStage2];

	// Get tuner IF stage 3 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_3_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage3 = (ReadingByte & RTL2832_E4000_IF_STAGE_3_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_3_GAIN_SHIFT;
	TunerGainIfStage3 = IfStage3GainTable[TunerBitsIfStage3];

	// Get tuner IF stage 4 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_4_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage4 = (ReadingByte & RTL2832_E4000_IF_STAGE_4_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_4_GAIN_SHIFT;
	TunerGainIfStage4 = IfStage4GainTable[TunerBitsIfStage4];

	// Get tuner IF stage 5 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_5_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage5 = (ReadingByte & RTL2832_E4000_IF_STAGE_5_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_5_GAIN_SHIFT;
	TunerGainIfStage5 = IfStage5GainTable[TunerBitsIfStage5];

	// Get tuner IF stage 6 gain according to reading byte and table.
	if(I2CReadByte(this, NO_USE, RTL2832_E4000_IF_STAGE_6_GAIN_ADDR, &ReadingByte) != E4000_I2C_SUCCESS)
		goto error_status_get_tuner_registers;

	TunerBitsIfStage6 = (ReadingByte & RTL2832_E4000_IF_STAGE_6_GAIN_MASK) >> RTL2832_E4000_IF_STAGE_6_GAIN_SHIFT;
	TunerGainIfStage6 = IfStage6GainTable[TunerBitsIfStage6];

	// Calculate tuner total gain.
	// Note: The unit of tuner total gain is 0.1 dB.
	TunerGainTotal = TunerGainLna + TunerGainLnaAdd + TunerGainMixer + 
	                 TunerGainIfStage1 + TunerGainIfStage2 + TunerGainIfStage3 + TunerGainIfStage4 +
	                 TunerGainIfStage5 + TunerGainIfStage6;

	// Calculate tuner input power.
	// Note: The unit of tuner input power is 0.1 dBm
	TunerInputPower = RTL2832_E4000_TUNER_OUTPUT_POWER_UNIT_0P1_DBM - TunerGainTotal;

/*	fprintf(stderr, _T("Current gain state:\n"
		"\tFreq:\t%i kHz\n"
		"\tBW:\t%i kHz\n"
		"\tLNA:\t%.1f dB\n"
		"\tLNA+:\t%.1f dB\n"
		"\tMixer:\t%.1f dB\n"
		"\tIF 1:\t%.1f dB\n"
		"\tIF 2:\t%.1f dB\n"
		"\tIF 3:\t%.1f dB\n"
		"\tIF 4:\t%.1f dB\n"
		"\tIF 5:\t%.1f dB\n"
		"\tIF 6:\t%.1f dB\n"
		"\tTotal:\t%.1f dB\n"
		"\tPower:\t%.1f dBm\n"),
		RfFreqKhz,
		BandwidthKhz,
		(float)TunerGainLna/10.0f,
		(float)TunerGainLnaAdd/10.0f,
		(float)TunerGainMixer/10.0f,
		(float)TunerGainIfStage1/10.0f,
		(float)TunerGainIfStage2/10.0f,
		(float)TunerGainIfStage3/10.0f,
		(float)TunerGainIfStage4/10.0f,
		(float)TunerGainIfStage5/10.0f,
		(float)TunerGainIfStage6/10.0f,
		(float)TunerGainTotal/10.0f,
		(float)TunerInputPower/10.0f);
*/
	// Determine tuner gain mode according to tuner input power.
	// Note: The unit of tuner input power is 0.1 dBm
	switch (m_iTunerGainMode)
	{
		default:
		case RTL2832_E4000_TUNER_GAIN_SENSITIVE:
			if(TunerInputPower > -650)
				TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
			break;

		case RTL2832_E4000_TUNER_GAIN_NORMAL:
			if(TunerInputPower < -750)
				TunerGainMode = RTL2832_E4000_TUNER_GAIN_SENSITIVE;
			if(TunerInputPower > -400)
				TunerGainMode = RTL2832_E4000_TUNER_GAIN_LINEAR;
			break;

		case RTL2832_E4000_TUNER_GAIN_LINEAR:
			if(TunerInputPower < -500)
				TunerGainMode = RTL2832_E4000_TUNER_GAIN_NORMAL;
			break;
	}

	if (m_iTunerGainMode != TunerGainMode)
	{
		switch (TunerGainMode)
		{
			case RTL2832_E4000_TUNER_GAIN_SENSITIVE:
				if (E4000_sensitivity(this, (int)(GetFreq()/1000), BANDWIDTH/1000) != E4000_I2C_SUCCESS)
					goto error_status_get_tuner_registers;
				fprintf(stderr, _T("Tuner gain mode: sensitive\n"));
				break;
			case RTL2832_E4000_TUNER_GAIN_LINEAR:
				if (E4000_linearity(this, (int)(GetFreq()/1000), BANDWIDTH/1000) != E4000_I2C_SUCCESS)
					goto error_status_get_tuner_registers;
				fprintf(stderr, _T("Tuner gain mode: sensitive\n"));
				break;
			case RTL2832_E4000_TUNER_GAIN_NORMAL:
			default:
				if (E4000_nominal(this, (int)(GetFreq()/1000), BANDWIDTH/1000) != E4000_I2C_SUCCESS)
					goto error_status_get_tuner_registers;
				fprintf(stderr, _T("Tuner gain mode: sensitive\n"));
				break;
		}

		m_iTunerGainMode = TunerGainMode;
	}

	goto set_tuner_mode_complete;

error_status_get_tuner_registers:
	fprintf(stderr, _T("Failed to set tuner gain mode\n"));
set_tuner_mode_complete:
	set_i2c_repeater(0);
	return TunerGainMode;
}
